{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "71353541",
   "metadata": {
    "id": "view-in-github",
    "papermill": {
     "duration": 0.003483,
     "end_time": "2024-05-15T23:00:04.722302",
     "exception": false,
     "start_time": "2024-05-15T23:00:04.718819",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "<a href=\"https://colab.research.google.com/github/nudojacopo/thesis/blob/main/HWK_labs.ipynb\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cdfd8a6f",
   "metadata": {
    "id": "hb5traIJtpJn",
    "papermill": {
     "duration": 0.002546,
     "end_time": "2024-05-15T23:00:04.728256",
     "exception": false,
     "start_time": "2024-05-15T23:00:04.725710",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Notes for Jacopo:"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2603870f",
   "metadata": {
    "id": "1RXSw25AtpJt",
    "papermill": {
     "duration": 0.002221,
     "end_time": "2024-05-15T23:00:04.733062",
     "exception": false,
     "start_time": "2024-05-15T23:00:04.730841",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "\n",
    " <br>\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ba804e4e",
   "metadata": {
    "id": "p9lCuzmYtpJt",
    "papermill": {
     "duration": 0.002128,
     "end_time": "2024-05-15T23:00:04.737628",
     "exception": false,
     "start_time": "2024-05-15T23:00:04.735500",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Define the module path + import packages"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "a87cbd98",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-05-15T23:00:04.744060Z",
     "iopub.status.busy": "2024-05-15T23:00:04.743636Z",
     "iopub.status.idle": "2024-05-15T23:00:04.754995Z",
     "shell.execute_reply": "2024-05-15T23:00:04.753456Z"
    },
    "id": "uJBUxmTXvLwZ",
    "outputId": "8c1de787-c679-44ff-fe4d-4a26be76e2d0",
    "papermill": {
     "duration": 0.017526,
     "end_time": "2024-05-15T23:00:04.757488",
     "exception": false,
     "start_time": "2024-05-15T23:00:04.739962",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "#kernel=input('Choose a kernel to use...are you running in local? Y/N')\n",
    "kernel='K'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "5325b6a9",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-05-15T23:00:04.764575Z",
     "iopub.status.busy": "2024-05-15T23:00:04.764191Z",
     "iopub.status.idle": "2024-05-15T23:00:13.551276Z",
     "shell.execute_reply": "2024-05-15T23:00:13.549938Z"
    },
    "id": "Y0HNlr43uyvd",
    "outputId": "ef43593d-a8ab-4b9e-c2fe-6694da998f9d",
    "papermill": {
     "duration": 8.793976,
     "end_time": "2024-05-15T23:00:13.554236",
     "exception": false,
     "start_time": "2024-05-15T23:00:04.760260",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Cloning into 'thesis'...\r\n",
      "remote: Enumerating objects: 362, done.\u001b[K\r\n",
      "remote: Counting objects: 100% (42/42), done.\u001b[K\r\n",
      "remote: Compressing objects: 100% (35/35), done.\u001b[K\r\n",
      "remote: Total 362 (delta 20), reused 15 (delta 7), pack-reused 320\u001b[K\r\n",
      "Receiving objects: 100% (362/362), 26.34 MiB | 41.36 MiB/s, done.\r\n",
      "Resolving deltas: 100% (150/150), done.\r\n",
      "/kaggle/working/thesis\n",
      "/kaggle/working/thesis/src\n",
      "/kaggle/working/thesis/src/HWK\n"
     ]
    }
   ],
   "source": [
    "if kernel=='C':\n",
    "  !git clone https://github.com/nudojacopo/thesis.git\n",
    "  from google.colab import drive\n",
    "  drive.mount('/content/drive')\n",
    "  source_data='/content/drive/MyDrive/thesis/data/voat/voat_labeled_data_unified.parquet'\n",
    "  root='/content/'\n",
    "if kernel=='K':\n",
    "  !rm -rf thesis\n",
    "  !git clone https://github.com/nudojacopo/thesis.git\n",
    "  %cd thesis\n",
    "  %cd src\n",
    "  %cd HWK\n",
    "  source_data='/kaggle/input/voat-dataset/voat_labeled_data_unified.parquet'\n",
    "  root='/kaggle/output/'\n",
    "  path='/kaggle/working/thesis/'\n",
    "else:\n",
    "  source_data='/Users/jacoponudo/Documents/thesis/data/voat/voat_labeled_data_unified.parquet'\n",
    "  root='/Users/jacoponudo/Documents/'\n",
    "output=root+'src/HWK/output'\n",
    "output_threads=root+'src/HWK/output/temporary'\n",
    "import sys\n",
    "module_path = root+'thesis/src/HWK'\n",
    "sys.path.append(module_path)\n",
    "import os\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "from tqdm import tqdm\n",
    "from HWK_package.functions import *\n",
    "from scipy import stats\n",
    "import random\n",
    "from scipy.stats import chi2\n",
    "import statsmodels.api as sm\n",
    "import matplotlib.pyplot as plt\n",
    "from statsmodels.graphics.gofplots import qqplot"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "9e303f6f",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-05-15T23:00:13.564644Z",
     "iopub.status.busy": "2024-05-15T23:00:13.564105Z",
     "iopub.status.idle": "2024-05-15T23:00:23.057523Z",
     "shell.execute_reply": "2024-05-15T23:00:23.055981Z"
    },
    "papermill": {
     "duration": 9.502163,
     "end_time": "2024-05-15T23:00:23.060218",
     "exception": false,
     "start_time": "2024-05-15T23:00:13.558055",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "from itertools import product\n",
    "from tqdm import tqdm\n",
    "from scipy.stats import kstest\n",
    "\n",
    "# Read dataset voat\n",
    "dataset = pd.read_parquet(source_data)\n",
    "root = dataset[dataset['root_submission'] == '0']\n",
    "root.to_csv('/kaggle/working/grid_search_Sintetizzatore.csv', index=False)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0e3dde48",
   "metadata": {
    "papermill": {
     "duration": 0.003638,
     "end_time": "2024-05-15T23:00:23.067810",
     "exception": false,
     "start_time": "2024-05-15T23:00:23.064172",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Il sintetizzatore"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "71167e67",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-05-15T23:00:23.077058Z",
     "iopub.status.busy": "2024-05-15T23:00:23.076705Z",
     "iopub.status.idle": "2024-05-15T23:00:23.087438Z",
     "shell.execute_reply": "2024-05-15T23:00:23.086064Z"
    },
    "papermill": {
     "duration": 0.01858,
     "end_time": "2024-05-15T23:00:23.090289",
     "exception": false,
     "start_time": "2024-05-15T23:00:23.071709",
     "status": "completed"
    },
    "scrolled": true,
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "\" import numpy as np\\nimport pandas as pd\\nfrom itertools import product\\nfrom tqdm import tqdm\\nfrom scipy.stats import kstest\\n\\n# Read dataset voat\\ndataset = pd.read_parquet(source_data)\\n\\n# Assuming dataset, root_submission, observed_data, start_conversation, end_conversation, ℋ_t, and x_values are defined\\nroot_submission_list=list(dataset.root_submission.sample(1))\\n\\n\\n# Lista dei parametri\\nlambda_grid = np.concatenate((np.arange(1, 100, 5), np.arange(100, 800, 100)))\\nalpha_grid = np.concatenate(([0.0001, 0.1, 0.5], np.arange(1, 60, 50)))\\nbeta_grid = np.arange(60, 190, 50)\\ntheta_combinations = list(product(lambda_grid, alpha_grid, beta_grid))\\nn_sim = 1\\n\\n# Lista per memorizzare i risultati\\nresults = []\\nx_values = np.arange(0, 1, 0.0001)  #griglia\\n\\n# Loop over root_submission\\nfor root_submission in tqdm(root_submission_list):\\n    root = dataset[dataset['root_submission'] == root_submission]\\n    root.to_csv('/kaggle/working/grid_search_Sintetizzatore.csv', index=False)\\n    root.sort_values(by='created_at', inplace=True)\\n    observed_data = np.array([np.datetime64(x.replace(tzinfo=None)).astype(np.int64) for x in root['created_at']])\\n    start_conversation = np.datetime64(min(root['created_at']).replace(tzinfo=None))\\n    end_conversation = np.datetime64(max(root['created_at']).replace(tzinfo=None))\\n    ℋ_t = (observed_data - start_conversation.astype(np.int64)) / (end_conversation.astype(np.int64) - start_conversation.astype(np.int64))\\n    root.loc[:, 'time'] = ℋ_t.copy()\\n    ECDF = np.array(F(x_values, ℋ_t))\\n\\n    # Esecuzione della grid search\\n    for l, alpha, beta in tqdm(theta_combinations, total=len(theta_combinations)):\\n        theta = np.array([l, alpha, beta])\\n        KS_sims = []\\n        for i in range(n_sim):\\n            ℋ_t_simulated = exp_simulate_by_composition_alt(theta, 1)\\n            SCDF = np.array(F(x_values, ℋ_t_simulated))\\n            KS, p_value = kstest(ECDF, SCDF)\\n            KS_sims.append(KS)\\n        results.append({'root': root_submission, 'lambda': l, 'alpha': alpha, 'beta': beta, 'KS_expected_value': np.mean(KS_sims), 'sd_exepected_value': np.std(KS_sims)})\\n\\n\""
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "''' import numpy as np\n",
    "import pandas as pd\n",
    "from itertools import product\n",
    "from tqdm import tqdm\n",
    "from scipy.stats import kstest\n",
    "\n",
    "# Read dataset voat\n",
    "dataset = pd.read_parquet(source_data)\n",
    "\n",
    "# Assuming dataset, root_submission, observed_data, start_conversation, end_conversation, ℋ_t, and x_values are defined\n",
    "root_submission_list=list(dataset.root_submission.sample(1))\n",
    "\n",
    "\n",
    "# Lista dei parametri\n",
    "lambda_grid = np.concatenate((np.arange(1, 100, 5), np.arange(100, 800, 100)))\n",
    "alpha_grid = np.concatenate(([0.0001, 0.1, 0.5], np.arange(1, 60, 50)))\n",
    "beta_grid = np.arange(60, 190, 50)\n",
    "theta_combinations = list(product(lambda_grid, alpha_grid, beta_grid))\n",
    "n_sim = 1\n",
    "\n",
    "# Lista per memorizzare i risultati\n",
    "results = []\n",
    "x_values = np.arange(0, 1, 0.0001)  #griglia\n",
    "\n",
    "# Loop over root_submission\n",
    "for root_submission in tqdm(root_submission_list):\n",
    "    root = dataset[dataset['root_submission'] == root_submission]\n",
    "    root.to_csv('/kaggle/working/grid_search_Sintetizzatore.csv', index=False)\n",
    "    root.sort_values(by='created_at', inplace=True)\n",
    "    observed_data = np.array([np.datetime64(x.replace(tzinfo=None)).astype(np.int64) for x in root['created_at']])\n",
    "    start_conversation = np.datetime64(min(root['created_at']).replace(tzinfo=None))\n",
    "    end_conversation = np.datetime64(max(root['created_at']).replace(tzinfo=None))\n",
    "    ℋ_t = (observed_data - start_conversation.astype(np.int64)) / (end_conversation.astype(np.int64) - start_conversation.astype(np.int64))\n",
    "    root.loc[:, 'time'] = ℋ_t.copy()\n",
    "    ECDF = np.array(F(x_values, ℋ_t))\n",
    "\n",
    "    # Esecuzione della grid search\n",
    "    for l, alpha, beta in tqdm(theta_combinations, total=len(theta_combinations)):\n",
    "        theta = np.array([l, alpha, beta])\n",
    "        KS_sims = []\n",
    "        for i in range(n_sim):\n",
    "            ℋ_t_simulated = exp_simulate_by_composition_alt(theta, 1)\n",
    "            SCDF = np.array(F(x_values, ℋ_t_simulated))\n",
    "            KS, p_value = kstest(ECDF, SCDF)\n",
    "            KS_sims.append(KS)\n",
    "        results.append({'root': root_submission, 'lambda': l, 'alpha': alpha, 'beta': beta, 'KS_expected_value': np.mean(KS_sims), 'sd_exepected_value': np.std(KS_sims)})\n",
    "\n",
    "'''\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "f2da99ff",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-05-15T23:00:23.100651Z",
     "iopub.status.busy": "2024-05-15T23:00:23.100223Z",
     "iopub.status.idle": "2024-05-15T23:00:23.108812Z",
     "shell.execute_reply": "2024-05-15T23:00:23.106727Z"
    },
    "papermill": {
     "duration": 0.016849,
     "end_time": "2024-05-15T23:00:23.111763",
     "exception": false,
     "start_time": "2024-05-15T23:00:23.094914",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "\"# Creazione del DataFrame\\ndf = pd.DataFrame(results)\\n\\n# Salvataggio del DataFrame su file CSV\\ndf.to_csv('/kaggle/working/grid_search_Sintetizzatore.csv', index=False)\\n\\ndf.to_csv('/kaggle/working/thesis/data/grid_search_Sintetizzatore.csv', index=False)\\n\\n# Stampare il DataFrame\\nprint(df)\""
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "'''# Creazione del DataFrame\n",
    "df = pd.DataFrame(results)\n",
    "\n",
    "# Salvataggio del DataFrame su file CSV\n",
    "df.to_csv('/kaggle/working/grid_search_Sintetizzatore.csv', index=False)\n",
    "\n",
    "df.to_csv('/kaggle/working/thesis/data/grid_search_Sintetizzatore.csv', index=False)\n",
    "\n",
    "# Stampare il DataFrame\n",
    "print(df)'''"
   ]
  }
 ],
 "metadata": {
  "colab": {
   "include_colab_link": true,
   "provenance": []
  },
  "kaggle": {
   "accelerator": "none",
   "dataSources": [
    {
     "datasetId": 5014954,
     "sourceId": 8423193,
     "sourceType": "datasetVersion"
    }
   ],
   "dockerImageVersionId": 30698,
   "isGpuEnabled": false,
   "isInternetEnabled": true,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.13"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 22.708886,
   "end_time": "2024-05-15T23:00:24.342505",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2024-05-15T23:00:01.633619",
   "version": "2.5.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
